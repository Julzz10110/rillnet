# Variables
TEST_TIMEOUT = 10m
RACE_DETECTOR = true
COVERAGE_FILE = ../coverage.out
COVERAGE_HTML = ../coverage.html
BENCH_TIME = 5s
STRESS_TEST_DURATION = 30s
STRESS_TEST_PEERS = 100
PERF_TEST_OPS = 1000

# Default targets
.PHONY: all unit integration load benchmark stress coverage clean help

all: unit integration

# Unit tests
unit:
	@echo "ðŸš€ Running unit tests..."
	@cd .. && go test ./tests/unit/... \
		-v \
		-timeout=$(TEST_TIMEOUT) \
		-coverprofile=$(COVERAGE_FILE)

unit-race:
	@echo "ðŸ Running unit tests with race detector..."
	@cd .. && CGO_ENABLED=1 go test ./tests/unit/... \
		-v \
		-race \
		-timeout=$(TEST_TIMEOUT) \
		-coverprofile=$(COVERAGE_FILE)

unit-verbose:
	@echo "ðŸ” Running unit tests with verbose output..."
	@cd .. && go test ./tests/unit/... -v -timeout=$(TEST_TIMEOUT)

unit-short:
	@echo "âš¡ Running quick unit tests..."
	@cd .. && go test ./tests/unit/... -short -timeout=2m

# Integration tests
integration:
	@echo "ðŸ”— Running integration tests..."
	@cd .. && go test ./tests/integration/... \
		-v \
		-timeout=15m \
		-tags=integration

integration-webrtc:
	@echo "ðŸ“¹ Running WebRTC integration tests..."
	@cd .. && go test ./tests/integration/webrtc_integration_test.go \
		-v \
		-timeout=10m \
		-tags=integration

integration-mesh:
	@echo "ðŸ•¸ï¸ Running mesh network integration tests..."
	@cd .. && go test ./tests/integration/mesh_integration_test.go \
		-v \
		-timeout=10m \
		-tags=integration

# Load tests
load:
	@echo "ðŸ“Š Running load tests..."
	@cd .. && go run tests/load/stress_test.go

load-custom:
	@echo "ðŸŽ¯ Running custom load test with $(STRESS_TEST_PEERS) peers for $(STRESS_TEST_DURATION)..."
	@cd .. && go run tests/load/stress_test.go \
		-peers $(STRESS_TEST_PEERS) \
		-duration $(STRESS_TEST_DURATION)

# Stress tests
stress:
	@echo "ðŸ”¥ Running stress tests..."
	@cd .. && go test ./tests/load/... \
		-v \
		-timeout=30m \
		-tags=stress

stress-short:
	@echo "ðŸ”¥ Running short stress tests..."
	@cd .. && go test ./tests/load/stress_test.go \
		-v \
		-timeout=5m \
		-run TestShortStress

# Benchmark tests
benchmark:
	@echo "â±ï¸ Running benchmark tests..."
	@cd .. && go test ./tests/load/... \
		-bench=. \
		-benchmem \
		-benchtime=$(BENCH_TIME) \
		-tags=benchmark

benchmark-cpu:
	@echo "ðŸ’» Running CPU benchmark tests..."
	@cd .. && go test ./tests/load/... \
		-bench=. \
		-benchmem \
		-cpuprofile=../cpu.pprof \
		-tags=benchmark

benchmark-memory:
	@echo "ðŸ§  Running memory benchmark tests..."
	@cd .. && go test ./tests/load/... \
		-bench=. \
		-benchmem \
		-memprofile=../mem.pprof \
		-tags=benchmark

# Code coverage
coverage:
	@echo "ðŸ“ˆ Generating test coverage report..."
	@cd .. && go test ./internal/... ./tests/unit/... \
		-coverprofile=$(COVERAGE_FILE) \
		-covermode=atomic
	@cd .. && go tool cover -html=$(COVERAGE_FILE) -o $(COVERAGE_HTML)
	@echo "âœ… Coverage report generated: $(COVERAGE_HTML)"

coverage-show:
	@if [ -f "$(COVERAGE_HTML)" ]; then \
		echo "ðŸ“Š Opening coverage report..."; \
		open $(COVERAGE_HTML) 2>/dev/null || xdg-open $(COVERAGE_HTML) 2>/dev/null || echo "Open $(COVERAGE_HTML) manually"; \
	else \
		echo "âŒ Coverage report not found. Run 'make coverage' first."; \
	fi

coverage-ci:
	@echo "ðŸ“Š Generating CI coverage report..."
	@cd .. && go test ./internal/... ./tests/unit/... \
		-coverprofile=$(COVERAGE_FILE) \
		-covermode=atomic
	@cd .. && go tool cover -func=$(COVERAGE_FILE)

# Service-specific tests
test-stream-service:
	@echo "ðŸŽ¬ Testing Stream Service..."
	@cd .. && go test ./tests/unit/services/stream_service_test.go \
		-v \
		-timeout=2m

test-mesh-service:
	@echo "ðŸ•¸ï¸ Testing Mesh Service..."
	@cd .. && go test ./tests/unit/services/mesh_service_test.go \
		-v \
		-timeout=2m

test-webrtc:
	@echo "ðŸ“¹ Testing WebRTC components..."
	@cd .. && go test ./tests/unit/webrtc/... \
		-v \
		-timeout=5m

test-repositories:
	@echo "ðŸ’¾ Testing repositories..."
	@cd .. && go test ./tests/unit/repositories/... \
		-v \
		-timeout=2m

# Tests with different environments
test-race:
	@echo "ðŸ Running tests with race detector..."
	@cd .. && go test ./tests/... \
		-race \
		-timeout=$(TEST_TIMEOUT)

test-verbose:
	@echo "ðŸ” Running tests with verbose output..."
	@cd .. && go test ./tests/... \
		-v \
		-timeout=$(TEST_TIMEOUT)

# Cleanup
clean:
	@echo "ðŸ§¹ Cleaning test artifacts..."
	@rm -f ../coverage.out ../coverage.html ../cpu.pprof ../mem.pprof ../*.test
	@find .. -name "*.test" -delete

clean-profiles:
	@echo "ðŸ§¹ Cleaning profile files..."
	@rm -f ../*.pprof

# Help
help:
	@echo "ðŸŽ¯ RillNet Test Management"
	@echo ""
	@echo "ðŸ“‹ Available targets:"
	@echo "  all              - Run all tests (unit + integration)"
	@echo "  unit             - Run unit tests"
	@echo "  integration      - Run integration tests"
	@echo "  load             - Run load tests"
	@echo "  stress           - Run stress tests"
	@echo "  benchmark        - Run benchmark tests"
	@echo "  coverage         - Generate coverage report"
	@echo ""
	@echo "ðŸ”§ Specific test targets:"
	@echo "  test-stream-service - Test stream service"
	@echo "  test-mesh-service   - Test mesh service"
	@echo "  test-webrtc         - Test WebRTC components"
	@echo "  test-repositories   - Test repositories"
	@echo ""
	@echo "âš™ï¸  Configuration:"
	@echo "  STRESS_TEST_PEERS=200 make load-custom"
	@echo "  STRESS_TEST_DURATION=1m make load-custom"
	@echo "  PERF_TEST_OPS=5000 make benchmark"
	@echo ""
	@echo "ðŸ§¹ Cleanup:"
	@echo "  clean            - Remove test artifacts"
	@echo "  clean-profiles   - Remove profile files"

# Aliases
test: unit
check: unit
ci: unit integration coverage-ci
perf: benchmark
validate: unit integration

# Version information
version:
	@echo "RillNet Test Suite v1.0.0"
	@go version

# Install test dependencies
deps:
	@echo "ðŸ“¦ Installing test dependencies..."
	@cd .. && go get -u github.com/stretchr/testify/assert
	@cd .. && go get -u github.com/stretchr/testify/mock
	@cd .. && go get -u github.com/stretchr/testify/require
	@echo "âœ… Dependencies installed"

# Check dependencies installation
check-deps:
	@echo "ðŸ” Checking test dependencies..."
	@cd .. && go list -m github.com/stretchr/testify > /dev/null 2>&1 && echo "âœ… testify installed" || echo "âŒ testify missing"
	@cd .. && go list -m github.com/pion/webrtc/v3 > /dev/null 2>&1 && echo "âœ… webrtc installed" || echo "âŒ webrtc missing"
	@cd .. && go list -m github.com/gin-gonic/gin > /dev/null 2>&1 && echo "âœ… gin installed" || echo "âŒ gin missing"

# Generate test data
test-data:
	@echo "ðŸ“ Generating test data..."
	@mkdir -p ../test-data/streams
	@mkdir -p ../test-data/peers
	@echo "âœ… Test data directories created"

# Docker tests
test-docker:
	@echo "ðŸ³ Running tests in Docker..."
	@docker build -t rillnet-tests -f ../deployments/docker/Dockerfile.test ..
	@docker run --rm rillnet-tests

# Parallel test execution
test-parallel:
	@echo "âš¡ Running tests in parallel..."
	@cd .. && go test ./tests/unit/... -parallel=4 -timeout=$(TEST_TIMEOUT)

# Tests with different log levels
test-debug:
	@echo "ðŸ› Running tests with debug logging..."
	@cd .. && RILLNET_LOG_LEVEL=debug go test ./tests/... -v -timeout=$(TEST_TIMEOUT)

test-silent:
	@echo "ðŸ¤« Running tests silently..."
	@cd .. && go test ./tests/... -timeout=$(TEST_TIMEOUT) 2>/dev/null || echo "Tests completed with status: $$?"

# Export test environment variables
export-test-env:
	@echo "ðŸ”§ Exporting test environment variables..."
	@export RILLNET_TEST_MODE=true
	@export RILLNET_LOG_LEVEL=info
	@export RILLNET_WEBRTC_MOCK=true
	@echo "âœ… Test environment variables exported"